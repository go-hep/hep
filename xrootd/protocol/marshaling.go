// Copyright 2018 The go-hep Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package protocol // import "go-hep.org/x/hep/xrootd/protocol"

import (
	"encoding/binary"
	"reflect"

	"github.com/pkg/errors"
)

// MarshalRequest encodes request body alongside with request and stream ids.
func MarshalRequest(requestID uint16, streamID StreamID, requestBody interface{}) ([]byte, error) {
	requestHeader := make([]byte, 4)

	copy(requestHeader, streamID[:])
	binary.BigEndian.PutUint16(requestHeader[2:], requestID)

	b, err := Marshal(requestBody)
	if err != nil {
		return nil, err
	}

	return append(requestHeader, b...), nil
}

// Marshal encodes a structure value into a slice of bytes following the XRootd protocol specification.
// Fields are encoded in the same order as they are specified in the struct definition.
// Each field is encoded in network byte order (BigEndian) without any alignment or padding.
// Slices and arrays of uint8 are binary copied without further encoding.
// Supported types are: uint8, uint16, int32, int64, slices and arrays of uint8.
func Marshal(x interface{}) ([]byte, error) {
	v := reflect.ValueOf(x)

	v = reflect.Indirect(v)

	if v.Kind() != reflect.Struct {
		return nil, errors.Errorf("encoder: cannot Marshal invalid type %T", x)
	}

	dataSize, err := sizeOf(v)
	if err != nil {
		return nil, err
	}

	data := make([]byte, dataSize)
	pos := 0
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldSize := 0
		switch field.Kind() {
		case reflect.Uint8:
			fieldSize = 1
			data[pos] = uint8(field.Uint())
		case reflect.Uint16:
			fieldSize = 2
			binary.BigEndian.PutUint16(data[pos:pos+fieldSize], uint16(field.Uint()))
		case reflect.Int32:
			fieldSize = 4
			binary.BigEndian.PutUint32(data[pos:pos+fieldSize], uint32(field.Int()))
		case reflect.Int64:
			fieldSize = 8
			binary.BigEndian.PutUint64(data[pos:pos+fieldSize], uint64(field.Int()))
		case reflect.Array, reflect.Slice:
			elementKind := field.Type().Elem().Kind()
			if elementKind != reflect.Uint8 {
				return nil, errors.Errorf("encoder: cannot Marshal array or slice of %s, only arrays / slices of uint8 are supported", elementKind)
			}

			fieldSize = field.Len()
			reflect.Copy(reflect.ValueOf(data[pos:pos+fieldSize]), field)
		default:
			return nil, errors.Errorf("encoder: cannot Marshal kind %s", field.Kind())
		}
		pos += fieldSize
	}

	return data, nil
}

// Unmarshal decodes data from byte slice following the XRootd protocol specification.
// Fields are decoded in the same order as they are specified in the struct definition.
// Each field is decoded from network byte order (BigEndian) without any alignment or padding.
// Slices and arrays of uint8 are binary copied without further decoding.
// Since the length of the slice is unknown, all bytes to the end of data is copied to it.
// Supported types are: uint8, uint16, int32, int64, slices and arrays of uint8.
func Unmarshal(data []byte, x interface{}) (err error) {
	v := reflect.ValueOf(x)

	if v.Kind() != reflect.Ptr {
		return errors.Errorf("encoder: cannot Unmarshal %s, pointer to the struct is expected", v.Kind())
	}

	v = v.Elem()

	if v.Kind() != reflect.Struct {
		return errors.Errorf("encoder: cannot Unmarshal %s, pointer to the struct is expected", v.Kind())
	}

	pos := 0

	for i := 0; i < v.NumField() && err == nil; i++ {
		field := v.Field(i)
		fieldSize := 0
		switch field.Kind() {
		case reflect.Uint8:
			fieldSize = 1
			field.SetUint(uint64(data[pos]))
		case reflect.Uint16:
			fieldSize = 2
			var value = binary.BigEndian.Uint16(data[pos : pos+fieldSize])
			field.SetUint(uint64(value))
		case reflect.Int32:
			fieldSize = 4
			var value = binary.BigEndian.Uint32(data[pos : pos+fieldSize])
			field.SetInt(int64(value))
		case reflect.Int64:
			fieldSize = 8
			var value = int64(binary.BigEndian.Uint64(data[pos : pos+fieldSize]))
			field.SetInt(value)
		case reflect.Slice:
			elementKind := field.Type().Elem().Kind()
			if elementKind != reflect.Uint8 {
				return errors.Errorf("encoder: cannot Unmarshal slice of %s, only slices of uint8 are supported", elementKind)
			}

			bytes := data[pos:]
			fieldSize = len(bytes)
			field.SetBytes(bytes)
		case reflect.Array:
			elementKind := field.Type().Elem().Kind()
			if elementKind != reflect.Uint8 {
				return errors.Errorf("encoder: cannot Unmarshal array of %s, only arrays of uint8 are supported", elementKind)
			}

			fieldSize = field.Len()
			reflect.Copy(field, reflect.ValueOf(data[pos:pos+fieldSize]))
		default:
			err = errors.Errorf("encoder: cannot Unmarshal kind %s", field.Kind())
		}
		pos += fieldSize
	}
	return
}

func sizeOf(v reflect.Value) (size int, err error) {
	for i := 0; i < v.NumField() && err == nil; i++ {
		field := v.Field(i)
		switch field.Kind() {
		case reflect.Uint8:
			size++
		case reflect.Uint16:
			size += 2
		case reflect.Int32:
			size += 4
		case reflect.Int64:
			size += 8
		case reflect.Array, reflect.Slice:
			size += field.Len()
		default:
			err = errors.Errorf("encoder: cannot Marshal kind %s", field.Kind())
		}
	}
	return
}
