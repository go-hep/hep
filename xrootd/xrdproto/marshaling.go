// Copyright 2018 The go-hep Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package xrdproto // import "go-hep.org/x/hep/xrootd/xrdproto"

import (
	"encoding/binary"
	"reflect"

	"github.com/pkg/errors"
	"go-hep.org/x/hep/xrootd/internal/xrdenc"
)

// Request is a XRootD request issued to a server.
type Request interface {
	// ReqID uniquely identifies the type of a request.
	ReqID() uint16

	// ShouldSign indicates whether this request should be signed if security level is SignLikely.
	// For the list of actual examples see XRootD protocol specification v. 3.1.0, p.76.
	ShouldSign() bool

	Marshaler
	Unmarshaler
}

// Response is a XRootD response returned by the server
type Response interface {
	RespID() uint16
	Marshaler
	Unmarshaler
}

// Marshaler is the interface implemented by a type that can marshal itself
// into a binary form, following the XRootD protocol.
//
// MarshalXrd encodes the receiver into a binary form and returns the result.
type Marshaler interface {
	MarshalXrd(enc *xrdenc.WBuffer) error
}

// Unmarshaler is the interface implemented by a type that can
// unmarshal a binary representation of itself, following the XRootD protocol.
//
// UnmarshalXrd must be able to decode the form generated by MarshalXrd.
// UnmarshalXrd must copy the data if it wishes to retain the data after
// returning.
type Unmarshaler interface {
	UnmarshalXrd(dec *xrdenc.RBuffer) error
}

// MarshalRequest encodes request body alongside with request and stream ids.
func MarshalRequest(requestID uint16, streamID StreamID, requestBody interface{}) ([]byte, error) {
	requestHeader := make([]byte, 4)

	copy(requestHeader, streamID[:])
	binary.BigEndian.PutUint16(requestHeader[2:], requestID)

	b, err := Marshal(requestBody)
	if err != nil {
		return nil, err
	}

	return append(requestHeader, b...), nil
}

// Marshal encodes a structure value into a slice of bytes following the XRootd protocol specification.
// Fields are encoded in the same order as they are specified in the struct definition.
// Each field is encoded in network byte order (BigEndian) without any alignment or padding.
// Slices and arrays of uint8 are binary copied without further encoding.
// Supported types are: uint8, uint16, int32, int64, slices and arrays of uint8.
func Marshal(x interface{}) ([]byte, error) {
	if x, ok := x.(Marshaler); ok {
		var wBuffer xrdenc.WBuffer
		err := x.MarshalXrd(&wBuffer)
		return wBuffer.Bytes(), err
	}

	v := reflect.ValueOf(x)

	v = reflect.Indirect(v)

	if v.Kind() != reflect.Struct {
		return nil, errors.Errorf("encoder: cannot Marshal invalid type %T", x)
	}

	dataSize, err := sizeOf(v)
	if err != nil {
		return nil, err
	}

	data := make([]byte, dataSize)
	pos := 0
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldSize := 0
		switch field.Kind() {
		case reflect.Uint8:
			fieldSize = 1
			data[pos] = uint8(field.Uint())
		case reflect.Uint16:
			fieldSize = 2
			binary.BigEndian.PutUint16(data[pos:pos+fieldSize], uint16(field.Uint()))
		case reflect.Int32:
			fieldSize = 4
			binary.BigEndian.PutUint32(data[pos:pos+fieldSize], uint32(field.Int()))
		case reflect.Int64:
			fieldSize = 8
			binary.BigEndian.PutUint64(data[pos:pos+fieldSize], uint64(field.Int()))
		case reflect.Array, reflect.Slice:
			elementKind := field.Type().Elem().Kind()
			if elementKind != reflect.Uint8 {
				return nil, errors.Errorf("encoder: cannot Marshal array or slice of %s, only arrays / slices of uint8 are supported", elementKind)
			}

			fieldSize = field.Len()
			reflect.Copy(reflect.ValueOf(data[pos:pos+fieldSize]), field)
		default:
			return nil, errors.Errorf("encoder: cannot Marshal kind %s", field.Kind())
		}
		pos += fieldSize
	}

	return data, nil
}

// Unmarshal decodes data from byte slice following the XRootd protocol specification.
// Fields are decoded in the same order as they are specified in the struct definition.
// Each field is decoded from network byte order (BigEndian) without any alignment or padding.
// Slices and arrays of uint8 are binary copied without further decoding.
// Since the length of the slice is unknown, all bytes to the end of data is copied to it.
// Supported types are: uint8, uint16, int32, int64, slices and arrays of uint8.
func Unmarshal(data []byte, x interface{}) (err error) {
	if x, ok := x.(Unmarshaler); ok {
		return x.UnmarshalXrd(xrdenc.NewRBuffer(data))
	}

	v := reflect.ValueOf(x)

	if v.Kind() != reflect.Ptr {
		return errors.Errorf("encoder: cannot Unmarshal %s, pointer to the struct is expected", v.Kind())
	}

	v = v.Elem()

	if v.Kind() != reflect.Struct {
		return errors.Errorf("encoder: cannot Unmarshal %s, pointer to the struct is expected", v.Kind())
	}

	pos := 0

	for i := 0; i < v.NumField() && err == nil; i++ {
		field := v.Field(i)
		fieldSize := 0
		switch field.Kind() {
		case reflect.Uint8:
			fieldSize = 1
			field.SetUint(uint64(data[pos]))
		case reflect.Uint16:
			fieldSize = 2
			var value = binary.BigEndian.Uint16(data[pos : pos+fieldSize])
			field.SetUint(uint64(value))
		case reflect.Int32:
			fieldSize = 4
			var value = binary.BigEndian.Uint32(data[pos : pos+fieldSize])
			field.SetInt(int64(value))
		case reflect.Int64:
			fieldSize = 8
			var value = int64(binary.BigEndian.Uint64(data[pos : pos+fieldSize]))
			field.SetInt(value)
		case reflect.Slice:
			elementKind := field.Type().Elem().Kind()
			if elementKind != reflect.Uint8 {
				return errors.Errorf("encoder: cannot Unmarshal slice of %s, only slices of uint8 are supported", elementKind)
			}

			bytes := data[pos:]
			fieldSize = len(bytes)
			field.SetBytes(bytes)
		case reflect.Array:
			elementKind := field.Type().Elem().Kind()
			if elementKind != reflect.Uint8 {
				return errors.Errorf("encoder: cannot Unmarshal array of %s, only arrays of uint8 are supported", elementKind)
			}

			fieldSize = field.Len()
			reflect.Copy(field, reflect.ValueOf(data[pos:pos+fieldSize]))
		default:
			err = errors.Errorf("encoder: cannot Unmarshal kind %s", field.Kind())
		}
		pos += fieldSize
	}
	return
}

func sizeOf(v reflect.Value) (size int, err error) {
	for i := 0; i < v.NumField() && err == nil; i++ {
		field := v.Field(i)
		switch field.Kind() {
		case reflect.Uint8:
			size++
		case reflect.Uint16:
			size += 2
		case reflect.Int32:
			size += 4
		case reflect.Int64:
			size += 8
		case reflect.Array, reflect.Slice:
			size += field.Len()
		default:
			err = errors.Errorf("encoder: cannot Marshal kind %s", field.Kind())
		}
	}
	return
}
