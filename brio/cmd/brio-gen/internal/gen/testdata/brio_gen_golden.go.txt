// DO NOT EDIT; automatically generated by brio-gen

package pkg

import (
	"encoding/binary"
	"math"
)

// MarshalBinary implements encoding.BinaryMarshaler
func (o *T1) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	if o.b {
		data = append(data, uint8(1))
	} else {
		data = append(data, uint8(0))
	}
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.u))
	data = append(data, buf[:8]...)
	data = append(data, byte(o.u8))
	binary.LittleEndian.PutUint16(buf[:2], o.u16)
	data = append(data, buf[:2]...)
	binary.LittleEndian.PutUint32(buf[:4], o.u32)
	data = append(data, buf[:4]...)
	binary.LittleEndian.PutUint64(buf[:8], o.u64)
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.i))
	data = append(data, buf[:8]...)
	data = append(data, byte(o.i8))
	binary.LittleEndian.PutUint16(buf[:2], uint16(o.i16))
	data = append(data, buf[:2]...)
	binary.LittleEndian.PutUint32(buf[:4], uint32(o.i32))
	data = append(data, buf[:4]...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.i64))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(o.f64))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:4], math.Float32bits(real(o.c64)))
	data = append(data, buf[:4]...)
	binary.LittleEndian.PutUint64(buf[:4], math.Float32bits(imag(o.c64)))
	data = append(data, buf[:4]...)
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(real(o.c128)))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(imag(o.c128)))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.str)))
	data = append(data, buf[:8]...)
	data = append(data, []byte(o.str)...)
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.bs)))
	data = append(data, buf[:8]...)
	data = append(data, o.bs...)
	for i := range o.arri64 {
		o := &o.arri64[i]
		binary.LittleEndian.PutUint64(buf[:8], uint64(o))
		data = append(data, buf[:8]...)
	}
	binary.LittleEndian.PutUint64(buf[:8], uint64(len(o.slii64)))
	data = append(data, buf[:8]...)
	for i := range o.slii64 {
		o := &o.slii64[i]
		binary.LittleEndian.PutUint64(buf[:8], uint64(o))
		data = append(data, buf[:8]...)
	}
	{
		v := *o.ptri64
		binary.LittleEndian.PutUint64(buf[:8], uint64(v))
		data = append(data, buf[:8]...)
	}
	{
		sub, err := o.t2.MarshalBinary()
		if err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
		data = append(data, buf[:8]...)
		data = append(data, sub...)
	}
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *T1) UnmarshalBinary(data []byte) (err error) {
	if data[i] == 1 {
		o.b = true
	} else {
		o.b = false
	}
	data = data[1:]
	o.u = uint(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.u8 = data[0]
	data = data[1:]
	o.u16 = binary.LittleEndian.Uint16(data[:2])
	data = data[2:]
	o.u32 = binary.LittleEndian.Uint32(data[:4])
	data = data[4:]
	o.u64 = binary.LittleEndian.Uint64(data[:8])
	data = data[8:]
	o.i = int(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.i8 = int8(data[0])
	data = data[1:]
	o.i16 = int16(binary.LittleEndian.Uint16(data[:2]))
	data = data[2:]
	o.i32 = int32(binary.LittleEndian.Uint32(data[:4]))
	data = data[4:]
	o.i64 = int64(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.f64 = math.Float64frombits(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	o.c64 = complex(math.Float32frombits(binary.LittleEndian.Uint32(data[:4])), math.Float32frombits(binary.LittleEndian.Uint32(data[4:8])))
	data = data[8:]
	o.c128 = complex(math.Float64frombits(binary.LittleEndian.Uint64(data[:8])), math.Float64frombits(binary.LittleEndian.Uint64(data[8:16])))
	data = data[16:]
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		o.str = string(data[:n])
		data = data[n:]
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		o.bs = make([]byte, n)
		data = data[8:]
		o.bs = append(o.bs, data[:n]...)
		data = data[n:]
	}
	for i := range o.arri64 {
		o.arri64[i] = int64(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		o.slii64 = make([]int64, n)
		data = data[8:]
		for i := range o.slii64 {
			o.slii64[i] = int64(binary.LittleEndian.Uint64(data[:8]))
			data = data[8:]
		}
	}
	{
		var v int64
		v = int64(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		o.ptri64 = &v

	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		err = o.t2.UnmarshalBinary(data[:n])
		if err != nil {
			return err
		}
		data = data[n:]
	}
	return err
}

// MarshalBinary implements encoding.BinaryMarshaler
func (o *T2) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	binary.LittleEndian.PutUint64(buf[:8], uint64(o.ID))
	data = append(data, buf[:8]...)
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *T2) UnmarshalBinary(data []byte) (err error) {
	o.ID = int64(binary.LittleEndian.Uint64(data[:8]))
	data = data[8:]
	return err
}

// MarshalBinary implements encoding.BinaryMarshaler
func (o *T3) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	{
		sub, err := o.Time.MarshalBinary()
		if err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
		data = append(data, buf[:8]...)
		data = append(data, sub...)
	}
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *T3) UnmarshalBinary(data []byte) (err error) {
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		err = o.Time.UnmarshalBinary(data[:n])
		if err != nil {
			return err
		}
		data = data[n:]
	}
	return err
}
