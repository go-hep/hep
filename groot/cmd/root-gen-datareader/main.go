// Copyright 2017 The go-hep Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Command root-gen-datareader generates a Go struct to easily read the
// event data type stored inside a Tree.
//
// Example:
//  $> root-gen-datareader -t tree testdata/small-flat-tree.root
//  // automatically generated by root-gen-datareader.
//  // DO NOT EDIT.
//
//  package event
//
//  type Data struct {
//  	Int32        int32       `groot:"Int32"`
//  	Int64        int64       `groot:"Int64"`
//  	UInt32       int32       `groot:"UInt32"`
//  	UInt64       int64       `groot:"UInt64"`
//  	Float32      float32     `groot:"Float32"`
//  	Float64      float64     `groot:"Float64"`
//  	ArrayInt32   [10]int32   `groot:"ArrayInt32"`
//  	ArrayInt64   [10]int64   `groot:"ArrayInt64"`
//  	ArrayInt32   [10]int32   `groot:"ArrayInt32"`
//  	ArrayInt64   [10]int64   `groot:"ArrayInt64"`
//  	ArrayFloat32 [10]float32 `groot:"ArrayFloat32"`
//  	ArrayFloat64 [10]float64 `groot:"ArrayFloat64"`
//  	N            int32       `groot:"N"`
//  	SliceInt32   []int32     `groot:"SliceInt32"`
//  	SliceInt64   []int64     `groot:"SliceInt64"`
//  	SliceInt32   []int32     `groot:"SliceInt32"`
//  	SliceInt64   []int64     `groot:"SliceInt64"`
//  	SliceFloat32 []float32   `groot:"SliceFloat32"`
//  	SliceFloat64 []float64   `groot:"SliceFloat64"`
//  }
package main // import "go-hep.org/x/hep/groot/cmd/root-gen-datareader"

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"text/template"

	"go-hep.org/x/hep/groot"
	"go-hep.org/x/hep/groot/rtree"
)

var (
	treeName   = flag.String("t", "tree", "name of the tree to inspect")
	pkgName    = flag.String("p", "event", "name of the package where to generate the data model")
	outName    = flag.String("o", "", "name of the file where to store the generated data model (STDOUT)")
	dataReader = flag.Bool("reader", false, "generate data reader code")
	verbose    = flag.Bool("v", false, "enable verbose mode")
)

func printf(format string, args ...interface{}) {
	if *verbose {
		log.Printf(format, args...)
	}
}

func main() {

	log.SetPrefix("root-gen-datareader: ")
	log.SetFlags(0)

	flag.Parse()

	if flag.NArg() <= 0 {
		log.Printf("missing input file name")
		flag.Usage()
		flag.PrintDefaults()
		os.Exit(1)
	}

	ctx := Context{
		Package: *pkgName,
		Defs: map[string]*StructDef{
			"DataReader": {
				Name:   "DataReader",
				Fields: nil,
			},
		},
		GenDataReader: *dataReader,
	}

	f, err := groot.Open(flag.Arg(0))
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	obj, err := f.Get(*treeName)
	if err != nil {
		log.Fatal(err)
	}
	tree := obj.(rtree.Tree)
	printf("entries: %v\n", tree.Entries())

	defs := ctx.Defs
	branches := tree.Branches()
	printf("branches: %d\n", len(branches))
	for i, br := range branches {
		bname := goName(br.Name())
		printf("branch[%3d]=%s (=> %s title=%q)\n", i, br.Name(), bname, br.Title())
		leaves := br.Leaves()
		printf("leaves: %d\n", len(leaves))
		brStruct := StructDef{Name: bname, Fields: nil}
		for j, leaf := range leaves {
			printf("  [%03d] leaf: %v (title=%q)\n", j, leaf.Name(), leaf.Title())
			lname := goName(leaf.Name())
			tname := leaf.TypeName()
			switch {
			case leaf.LeafCount() != nil:
				tname = "[]" + tname
			case leaf.Len() > 1:
				tname = fmt.Sprintf("[%d]%s", leaf.Len(), tname)
			}
			brField := FieldDef{
				Name:       lname,
				BranchName: leaf.Name(),
				VarName:    lname,
				Type:       tname,
			}
			if j == 0 {
				brField.VarName = br.Name() + "." + lname
			}
			brStruct.Fields = append(brStruct.Fields, brField)
		}
		if len(brStruct.Fields) > 1 {
			defs[bname] = &brStruct
			defs["DataReader"].Fields = append(
				defs["DataReader"].Fields,
				FieldDef{
					Name:       bname,
					BranchName: br.Name(),
					VarName:    brStruct.Fields[0].VarName,
					Type:       bname,
				},
			)
		} else {
			defs["DataReader"].Fields = append(
				defs["DataReader"].Fields,
				brStruct.Fields...,
			)
		}
	}

	ctx.DataReader = defs["DataReader"]
	delete(defs, "DataReader")

	var o io.WriteCloser = os.Stdout
	if *outName != "" {
		o, err = os.Create(*outName)
		if err != nil {
			log.Fatal(err)
		}
	}

	err = genCode(o, ctx)
	if err != nil {
		log.Fatal(err)
	}
}

func goName(s string) string {
	return "ROOT_" + s
}

// StructDef models a TTree content as a Go struct, where each TBranch
// of the tree is translated as a field of the struct.
type StructDef struct {
	Name   string
	Fields []FieldDef
}

// FieldDef describes a Go struct field, corresponding to a TTree's branch.
type FieldDef struct {
	Name       string
	Type       string
	VarName    string
	BranchName string
}

// Context holds together various informations about the TTree being processed.
type Context struct {
	Package       string
	DataReader    *StructDef
	Defs          map[string]*StructDef
	GenDataReader bool
}

func genCode(w io.Writer, ctx Context) error {
	t := template.New("top")
	template.Must(t.Parse(codeTmpl))
	buf := new(bytes.Buffer)
	err := t.Execute(buf, ctx)
	if err != nil {
		return err
	}
	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	_, err = w.Write(src)
	return err
}

const codeTmpl = `// automatically generated by root-gen-datareader.
// DO NOT EDIT.

package {{.Package}}

{{if .GenDataReader}}import (
  "fmt"

  "go-hep.org/x/hep/groot/rtree"
){{end}}

{{range .Defs}}
type {{.Name}} struct {
{{range .Fields}}	{{.Name}} {{.Type}}
{{end}}}
{{end}}


{{with .DataReader}}
// Data is the data contained in a rtree.Tree.
type Data struct {
{{ range .Fields}}	{{.Name}} {{.Type}} ` + "`groot:\"{{.BranchName}}\"`" + `
{{ end}}}
{{end}}

{{if .GenDataReader}}
{{with .DataReader}}
type DataReader struct {
	Data    Data
	Tree    rtree.Tree
	Scanner *rtree.Scanner
}
{{end}}
{{end}}
`
