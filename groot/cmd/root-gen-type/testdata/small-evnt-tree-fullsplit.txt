// DO NOT EDIT; automatically generated by root-gen-type

package main

import (
	"reflect"

	"github.com/pkg/errors"
	"go-hep.org/x/hep/groot/rbytes"
	"go-hep.org/x/hep/groot/root"
	"go-hep.org/x/hep/groot/rtypes"
	"go-hep.org/x/hep/groot/rvers"
)

type Event struct {
	Beg       string
	I16       int16
	I32       int32
	I64       int64
	U16       uint16
	U32       uint32
	U64       uint64
	F32       float32
	F64       float64
	Str       string
	P3        P3
	ArrayI16  [10]int16
	ArrayI32  [10]int32
	ArrayI64  [10]int64
	ArrayU16  [10]uint16
	ArrayU32  [10]uint32
	ArrayU64  [10]uint64
	ArrayF32  [10]float32
	ArrayF64  [10]float64
	N         int32
	SliceI16  []int16   // [N]
	SliceI32  []int32   // [N]
	SliceI64  []int64   // [N]
	SliceU16  []uint16  // [N]
	SliceU32  []uint32  // [N]
	SliceU64  []uint64  // [N]
	SliceF32  []float32 // [N]
	SliceF64  []float64 // [N]
	StdStr    string
	StlVecI16 []int16
	StlVecI32 []int32
	StlVecI64 []int64
	StlVecU16 []uint16
	StlVecU32 []uint32
	StlVecU64 []uint64
	StlVecF32 []float32
	StlVecF64 []float64
	StlVecStr []string
	End       string
}

func (*Event) Class() string   { return "Event" }
func (*Event) RVersion() int16 { return 1 }

// MarshalROOT implements rbytes.Marshaler
func (o *Event) MarshalROOT(w *rbytes.WBuffer) (int, error) {
	if w.Err() != nil {
		return 0, w.Err()
	}

	pos := w.WriteVersion(o.RVersion())

	w.WriteString(o.Beg)
	w.WriteI16(o.I16)
	w.WriteI32(o.I32)
	w.WriteI64(o.I64)
	w.WriteU16(o.U16)
	w.WriteU32(o.U32)
	w.WriteU64(o.U64)
	w.WriteF32(o.F32)
	w.WriteF64(o.F64)
	w.WriteString(o.Str)
	o.P3.MarshalROOT(w) // obj-any
	w.WriteFastArrayI16(o.ArrayI16[:10])
	w.WriteFastArrayI32(o.ArrayI32[:10])
	w.WriteFastArrayI64(o.ArrayI64[:10])
	w.WriteFastArrayU16(o.ArrayU16[:10])
	w.WriteFastArrayU32(o.ArrayU32[:10])
	w.WriteFastArrayU64(o.ArrayU64[:10])
	w.WriteFastArrayF32(o.ArrayF32[:10])
	w.WriteFastArrayF64(o.ArrayF64[:10])
	w.WriteI32(int32(o.N))
	w.WriteI8(1) // is-array
	w.WriteFastArrayI16(o.SliceI16[:o.N])
	w.WriteI8(1) // is-array
	w.WriteFastArrayI32(o.SliceI32[:o.N])
	w.WriteI8(1) // is-array
	w.WriteFastArrayI64(o.SliceI64[:o.N])
	w.WriteI8(1) // is-array
	w.WriteFastArrayU16(o.SliceU16[:o.N])
	w.WriteI8(1) // is-array
	w.WriteFastArrayU32(o.SliceU32[:o.N])
	w.WriteI8(1) // is-array
	w.WriteFastArrayU64(o.SliceU64[:o.N])
	w.WriteI8(1) // is-array
	w.WriteFastArrayF32(o.SliceF32[:o.N])
	w.WriteI8(1) // is-array
	w.WriteFastArrayF64(o.SliceF64[:o.N])
	w.WriteSTLString(o.StdStr)
	{
		pos := w.WriteVersion(rvers.StreamerInfo)
		w.WriteI32(int32(len(o.StlVecI16)))
		w.WriteFastArrayI16(o.StlVecI16)
		if _, err := w.SetByteCount(pos, "vector<short>"); err != nil {
			w.SetErr(err)
			return 0, w.Err()
		}
	}
	{
		pos := w.WriteVersion(rvers.StreamerInfo)
		w.WriteI32(int32(len(o.StlVecI32)))
		w.WriteFastArrayI32(o.StlVecI32)
		if _, err := w.SetByteCount(pos, "vector<int>"); err != nil {
			w.SetErr(err)
			return 0, w.Err()
		}
	}
	{
		pos := w.WriteVersion(rvers.StreamerInfo)
		w.WriteI32(int32(len(o.StlVecI64)))
		w.WriteFastArrayI64(o.StlVecI64)
		if _, err := w.SetByteCount(pos, "vector<long>"); err != nil {
			w.SetErr(err)
			return 0, w.Err()
		}
	}
	{
		pos := w.WriteVersion(rvers.StreamerInfo)
		w.WriteI32(int32(len(o.StlVecU16)))
		w.WriteFastArrayU16(o.StlVecU16)
		if _, err := w.SetByteCount(pos, "vector<unsigned short>"); err != nil {
			w.SetErr(err)
			return 0, w.Err()
		}
	}
	{
		pos := w.WriteVersion(rvers.StreamerInfo)
		w.WriteI32(int32(len(o.StlVecU32)))
		w.WriteFastArrayU32(o.StlVecU32)
		if _, err := w.SetByteCount(pos, "vector<unsigned int>"); err != nil {
			w.SetErr(err)
			return 0, w.Err()
		}
	}
	{
		pos := w.WriteVersion(rvers.StreamerInfo)
		w.WriteI32(int32(len(o.StlVecU64)))
		w.WriteFastArrayU64(o.StlVecU64)
		if _, err := w.SetByteCount(pos, "vector<unsigned long>"); err != nil {
			w.SetErr(err)
			return 0, w.Err()
		}
	}
	{
		pos := w.WriteVersion(rvers.StreamerInfo)
		w.WriteI32(int32(len(o.StlVecF32)))
		w.WriteFastArrayF32(o.StlVecF32)
		if _, err := w.SetByteCount(pos, "vector<float>"); err != nil {
			w.SetErr(err)
			return 0, w.Err()
		}
	}
	{
		pos := w.WriteVersion(rvers.StreamerInfo)
		w.WriteI32(int32(len(o.StlVecF64)))
		w.WriteFastArrayF64(o.StlVecF64)
		if _, err := w.SetByteCount(pos, "vector<double>"); err != nil {
			w.SetErr(err)
			return 0, w.Err()
		}
	}
	{
		pos := w.WriteVersion(rvers.StreamerInfo)
		w.WriteI32(int32(len(o.StlVecStr)))
		w.WriteFastArrayString(o.StlVecStr)
		if _, err := w.SetByteCount(pos, "vector<string>"); err != nil {
			w.SetErr(err)
			return 0, w.Err()
		}
	}
	w.WriteString(o.End)

	return w.SetByteCount(pos, o.Class())
}

// UnmarshalROOT implements rbytes.Unmarshaler
func (o *Event) UnmarshalROOT(r *rbytes.RBuffer) error {
	if r.Err() != nil {
		return r.Err()
	}

	start := r.Pos()
	/*vers*/ _, pos, bcnt := r.ReadVersion(o.Class())

	o.Beg = r.ReadString()
	o.I16 = r.ReadI16()
	o.I32 = r.ReadI32()
	o.I64 = r.ReadI64()
	o.U16 = r.ReadU16()
	o.U32 = r.ReadU32()
	o.U64 = r.ReadU64()
	o.F32 = r.ReadF32()
	o.F64 = r.ReadF64()
	o.Str = r.ReadString()
	o.P3.UnmarshalROOT(r) // obj-any
	copy(o.ArrayI16[:], r.ReadFastArrayI16(len(o.ArrayI16)))
	copy(o.ArrayI32[:], r.ReadFastArrayI32(len(o.ArrayI32)))
	copy(o.ArrayI64[:], r.ReadFastArrayI64(len(o.ArrayI64)))
	copy(o.ArrayU16[:], r.ReadFastArrayU16(len(o.ArrayU16)))
	copy(o.ArrayU32[:], r.ReadFastArrayU32(len(o.ArrayU32)))
	copy(o.ArrayU64[:], r.ReadFastArrayU64(len(o.ArrayU64)))
	copy(o.ArrayF32[:], r.ReadFastArrayF32(len(o.ArrayF32)))
	copy(o.ArrayF64[:], r.ReadFastArrayF64(len(o.ArrayF64)))
	o.N = r.ReadI32()
	_ = r.ReadI8() // is-array
	o.SliceI16 = r.ReadFastArrayI16(int(o.N))
	_ = r.ReadI8() // is-array
	o.SliceI32 = r.ReadFastArrayI32(int(o.N))
	_ = r.ReadI8() // is-array
	o.SliceI64 = r.ReadFastArrayI64(int(o.N))
	_ = r.ReadI8() // is-array
	o.SliceU16 = r.ReadFastArrayU16(int(o.N))
	_ = r.ReadI8() // is-array
	o.SliceU32 = r.ReadFastArrayU32(int(o.N))
	_ = r.ReadI8() // is-array
	o.SliceU64 = r.ReadFastArrayU64(int(o.N))
	_ = r.ReadI8() // is-array
	o.SliceF32 = r.ReadFastArrayF32(int(o.N))
	_ = r.ReadI8() // is-array
	o.SliceF64 = r.ReadFastArrayF64(int(o.N))
	o.StdStr = r.ReadSTLString()
	{
		vers, pos, bcnt := r.ReadVersion("vector<short>")
		if vers != rvers.StreamerInfo {
			r.SetErr(errors.Errorf("rbytes: invalid version for \"vector<short>\". got=%v, want=%v", vers, rvers.StreamerInfo))
			return r.Err()
		}
		o.StlVecI16 = r.ReadFastArrayI16(int(r.ReadI32()))
		r.CheckByteCount(pos, bcnt, start, "vector<short>")
	}
	{
		vers, pos, bcnt := r.ReadVersion("vector<int>")
		if vers != rvers.StreamerInfo {
			r.SetErr(errors.Errorf("rbytes: invalid version for \"vector<int>\". got=%v, want=%v", vers, rvers.StreamerInfo))
			return r.Err()
		}
		o.StlVecI32 = r.ReadFastArrayI32(int(r.ReadI32()))
		r.CheckByteCount(pos, bcnt, start, "vector<int>")
	}
	{
		vers, pos, bcnt := r.ReadVersion("vector<long>")
		if vers != rvers.StreamerInfo {
			r.SetErr(errors.Errorf("rbytes: invalid version for \"vector<long>\". got=%v, want=%v", vers, rvers.StreamerInfo))
			return r.Err()
		}
		o.StlVecI64 = r.ReadFastArrayI64(int(r.ReadI32()))
		r.CheckByteCount(pos, bcnt, start, "vector<long>")
	}
	{
		vers, pos, bcnt := r.ReadVersion("vector<unsigned short>")
		if vers != rvers.StreamerInfo {
			r.SetErr(errors.Errorf("rbytes: invalid version for \"vector<unsigned short>\". got=%v, want=%v", vers, rvers.StreamerInfo))
			return r.Err()
		}
		o.StlVecU16 = r.ReadFastArrayU16(int(r.ReadI32()))
		r.CheckByteCount(pos, bcnt, start, "vector<unsigned short>")
	}
	{
		vers, pos, bcnt := r.ReadVersion("vector<unsigned int>")
		if vers != rvers.StreamerInfo {
			r.SetErr(errors.Errorf("rbytes: invalid version for \"vector<unsigned int>\". got=%v, want=%v", vers, rvers.StreamerInfo))
			return r.Err()
		}
		o.StlVecU32 = r.ReadFastArrayU32(int(r.ReadI32()))
		r.CheckByteCount(pos, bcnt, start, "vector<unsigned int>")
	}
	{
		vers, pos, bcnt := r.ReadVersion("vector<unsigned long>")
		if vers != rvers.StreamerInfo {
			r.SetErr(errors.Errorf("rbytes: invalid version for \"vector<unsigned long>\". got=%v, want=%v", vers, rvers.StreamerInfo))
			return r.Err()
		}
		o.StlVecU64 = r.ReadFastArrayU64(int(r.ReadI32()))
		r.CheckByteCount(pos, bcnt, start, "vector<unsigned long>")
	}
	{
		vers, pos, bcnt := r.ReadVersion("vector<float>")
		if vers != rvers.StreamerInfo {
			r.SetErr(errors.Errorf("rbytes: invalid version for \"vector<float>\". got=%v, want=%v", vers, rvers.StreamerInfo))
			return r.Err()
		}
		o.StlVecF32 = r.ReadFastArrayF32(int(r.ReadI32()))
		r.CheckByteCount(pos, bcnt, start, "vector<float>")
	}
	{
		vers, pos, bcnt := r.ReadVersion("vector<double>")
		if vers != rvers.StreamerInfo {
			r.SetErr(errors.Errorf("rbytes: invalid version for \"vector<double>\". got=%v, want=%v", vers, rvers.StreamerInfo))
			return r.Err()
		}
		o.StlVecF64 = r.ReadFastArrayF64(int(r.ReadI32()))
		r.CheckByteCount(pos, bcnt, start, "vector<double>")
	}
	{
		vers, pos, bcnt := r.ReadVersion("vector<string>")
		if vers != rvers.StreamerInfo {
			r.SetErr(errors.Errorf("rbytes: invalid version for \"vector<string>\". got=%v, want=%v", vers, rvers.StreamerInfo))
			return r.Err()
		}
		o.StlVecStr = r.ReadFastArrayString(int(r.ReadI32()))
		r.CheckByteCount(pos, bcnt, start, "vector<string>")
	}
	o.End = r.ReadString()

	r.CheckByteCount(pos, bcnt, start, o.Class())
	return r.Err()
}

func init() {
	f := func() reflect.Value {
		var o Event
		return reflect.ValueOf(&o)
	}
	rtypes.Factory.Add("Event", f)
}

var (
	_ root.Object        = (*Event)(nil)
	_ rbytes.RVersioner  = (*Event)(nil)
	_ rbytes.Marshaler   = (*Event)(nil)
	_ rbytes.Unmarshaler = (*Event)(nil)
)

type P3 struct {
	Px int32
	Py float64
	Pz int32
}

func (*P3) Class() string   { return "P3" }
func (*P3) RVersion() int16 { return 1 }

// MarshalROOT implements rbytes.Marshaler
func (o *P3) MarshalROOT(w *rbytes.WBuffer) (int, error) {
	if w.Err() != nil {
		return 0, w.Err()
	}

	pos := w.WriteVersion(o.RVersion())

	w.WriteI32(o.Px)
	w.WriteF64(o.Py)
	w.WriteI32(o.Pz)

	return w.SetByteCount(pos, o.Class())
}

// UnmarshalROOT implements rbytes.Unmarshaler
func (o *P3) UnmarshalROOT(r *rbytes.RBuffer) error {
	if r.Err() != nil {
		return r.Err()
	}

	start := r.Pos()
	/*vers*/ _, pos, bcnt := r.ReadVersion(o.Class())

	o.Px = r.ReadI32()
	o.Py = r.ReadF64()
	o.Pz = r.ReadI32()

	r.CheckByteCount(pos, bcnt, start, o.Class())
	return r.Err()
}

func init() {
	f := func() reflect.Value {
		var o P3
		return reflect.ValueOf(&o)
	}
	rtypes.Factory.Add("P3", f)
}

var (
	_ root.Object        = (*P3)(nil)
	_ rbytes.RVersioner  = (*P3)(nil)
	_ rbytes.Marshaler   = (*P3)(nil)
	_ rbytes.Unmarshaler = (*P3)(nil)
)
