// DO NOT EDIT; automatically generated by root-gen-type

package main

import (
	"fmt"
	"reflect"

	"go-hep.org/x/hep/groot/rbase"
	"go-hep.org/x/hep/groot/rbytes"
	"go-hep.org/x/hep/groot/rdict"
	"go-hep.org/x/hep/groot/rmeta"
	"go-hep.org/x/hep/groot/root"
	"go-hep.org/x/hep/groot/rtypes"
)

type D1 struct {
	base0 Base  `groot:"BASE-Base"` // base class
	D32   int32 `groot:"D32"`
}

func (*D1) Class() string {
	return "D1"
}

func (*D1) RVersion() int16 {
	return 1
}

// MarshalROOT implements rbytes.Marshaler
func (o *D1) MarshalROOT(w *rbytes.WBuffer) (int, error) {
	if w.Err() != nil {
		return 0, w.Err()
	}

	hdr := w.WriteHeader(o.Class(), o.RVersion())

	w.WriteObject(&o.base0)
	w.WriteI32(o.D32)

	return w.SetHeader(hdr)
}

// UnmarshalROOT implements rbytes.Unmarshaler
func (o *D1) UnmarshalROOT(r *rbytes.RBuffer) error {
	if r.Err() != nil {
		return r.Err()
	}

	hdr := r.ReadHeader(o.Class())
	if hdr.Vers > o.RVersion() {
		panic(fmt.Errorf(
			"rbytes: invalid %s version=%d > %d",
			o.Class(), hdr.Vers, o.RVersion(),
		))
	}

	r.ReadObject(&o.base0)
	o.D32 = r.ReadI32()

	r.CheckHeader(hdr)
	return r.Err()
}

func init() {
	f := func() reflect.Value {
		var o D1
		return reflect.ValueOf(&o)
	}
	rtypes.Factory.Add("D1", f)
}

func init() {
	// Streamer for D1.
	rdict.StreamerInfos.Add(rdict.NewCxxStreamerInfo("D1", 1, 0x665ff02a, []rbytes.StreamerElement{
		rdict.NewStreamerBase(rdict.Element{
			Name:   *rbase.NewNamed("Base", ""),
			Type:   rmeta.Base,
			Size:   0,
			ArrLen: 0,
			ArrDim: 0,
			MaxIdx: [5]int32{0, 2285240, 0, 0, 0},
			Offset: 0,
			EName:  "BASE",
			XMin:   0.000000,
			XMax:   0.000000,
			Factor: 0.000000,
		}.New(), -1),
		&rdict.StreamerBasicType{StreamerElement: rdict.Element{
			Name:   *rbase.NewNamed("D32", ""),
			Type:   rmeta.Int,
			Size:   4,
			ArrLen: 0,
			ArrDim: 0,
			MaxIdx: [5]int32{0, 0, 0, 0, 0},
			Offset: 0,
			EName:  "int",
			XMin:   0.000000,
			XMax:   0.000000,
			Factor: 0.000000,
		}.New()},
	}))
}

var (
	_ root.Object        = (*D1)(nil)
	_ rbytes.RVersioner  = (*D1)(nil)
	_ rbytes.Marshaler   = (*D1)(nil)
	_ rbytes.Unmarshaler = (*D1)(nil)
)

type Base struct {
	I32 int32 `groot:"I32"`
}

func (*Base) Class() string {
	return "Base"
}

func (*Base) RVersion() int16 {
	return 1
}

// MarshalROOT implements rbytes.Marshaler
func (o *Base) MarshalROOT(w *rbytes.WBuffer) (int, error) {
	if w.Err() != nil {
		return 0, w.Err()
	}

	hdr := w.WriteHeader(o.Class(), o.RVersion())

	w.WriteI32(o.I32)

	return w.SetHeader(hdr)
}

// UnmarshalROOT implements rbytes.Unmarshaler
func (o *Base) UnmarshalROOT(r *rbytes.RBuffer) error {
	if r.Err() != nil {
		return r.Err()
	}

	hdr := r.ReadHeader(o.Class())
	if hdr.Vers > o.RVersion() {
		panic(fmt.Errorf(
			"rbytes: invalid %s version=%d > %d",
			o.Class(), hdr.Vers, o.RVersion(),
		))
	}

	o.I32 = r.ReadI32()

	r.CheckHeader(hdr)
	return r.Err()
}

func init() {
	f := func() reflect.Value {
		var o Base
		return reflect.ValueOf(&o)
	}
	rtypes.Factory.Add("Base", f)
}

func init() {
	// Streamer for Base.
	rdict.StreamerInfos.Add(rdict.NewCxxStreamerInfo("Base", 1, 0x22deb8, []rbytes.StreamerElement{
		&rdict.StreamerBasicType{StreamerElement: rdict.Element{
			Name:   *rbase.NewNamed("I32", ""),
			Type:   rmeta.Int,
			Size:   4,
			ArrLen: 0,
			ArrDim: 0,
			MaxIdx: [5]int32{0, 0, 0, 0, 0},
			Offset: 0,
			EName:  "int",
			XMin:   0.000000,
			XMax:   0.000000,
			Factor: 0.000000,
		}.New()},
	}))
}

var (
	_ root.Object        = (*Base)(nil)
	_ rbytes.RVersioner  = (*Base)(nil)
	_ rbytes.Marshaler   = (*Base)(nil)
	_ rbytes.Unmarshaler = (*Base)(nil)
)

type D2 struct {
	base0 Base  `groot:"BASE-Base"` // base class
	I32   int32 `groot:"I32"`
}

func (*D2) Class() string {
	return "D2"
}

func (*D2) RVersion() int16 {
	return 1
}

// MarshalROOT implements rbytes.Marshaler
func (o *D2) MarshalROOT(w *rbytes.WBuffer) (int, error) {
	if w.Err() != nil {
		return 0, w.Err()
	}

	hdr := w.WriteHeader(o.Class(), o.RVersion())

	w.WriteObject(&o.base0)
	w.WriteI32(o.I32)

	return w.SetHeader(hdr)
}

// UnmarshalROOT implements rbytes.Unmarshaler
func (o *D2) UnmarshalROOT(r *rbytes.RBuffer) error {
	if r.Err() != nil {
		return r.Err()
	}

	hdr := r.ReadHeader(o.Class())
	if hdr.Vers > o.RVersion() {
		panic(fmt.Errorf(
			"rbytes: invalid %s version=%d > %d",
			o.Class(), hdr.Vers, o.RVersion(),
		))
	}

	r.ReadObject(&o.base0)
	o.I32 = r.ReadI32()

	r.CheckHeader(hdr)
	return r.Err()
}

func init() {
	f := func() reflect.Value {
		var o D2
		return reflect.ValueOf(&o)
	}
	rtypes.Factory.Add("D2", f)
}

func init() {
	// Streamer for D2.
	rdict.StreamerInfos.Add(rdict.NewCxxStreamerInfo("D2", 1, 0x6662a8e4, []rbytes.StreamerElement{
		rdict.NewStreamerBase(rdict.Element{
			Name:   *rbase.NewNamed("Base", ""),
			Type:   rmeta.Base,
			Size:   0,
			ArrLen: 0,
			ArrDim: 0,
			MaxIdx: [5]int32{0, 2285240, 0, 0, 0},
			Offset: 0,
			EName:  "BASE",
			XMin:   0.000000,
			XMax:   0.000000,
			Factor: 0.000000,
		}.New(), -1),
		&rdict.StreamerBasicType{StreamerElement: rdict.Element{
			Name:   *rbase.NewNamed("I32", ""),
			Type:   rmeta.Int,
			Size:   4,
			ArrLen: 0,
			ArrDim: 0,
			MaxIdx: [5]int32{0, 0, 0, 0, 0},
			Offset: 0,
			EName:  "int",
			XMin:   0.000000,
			XMax:   0.000000,
			Factor: 0.000000,
		}.New()},
	}))
}

var (
	_ root.Object        = (*D2)(nil)
	_ rbytes.RVersioner  = (*D2)(nil)
	_ rbytes.Marshaler   = (*D2)(nil)
	_ rbytes.Unmarshaler = (*D2)(nil)
)
