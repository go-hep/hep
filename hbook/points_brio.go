// DO NOT EDIT; automatically generated by brio-gen

package hbook

import (
	"encoding/binary"
	"math"
)

// MarshalBinary implements encoding.BinaryMarshaler
func (o *Point2D) MarshalBinary() (data []byte, err error) {
	var buf [8]byte
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(o.X))
	data = append(data, buf[:8]...)
	binary.LittleEndian.PutUint64(buf[:8], math.Float64bits(o.Y))
	data = append(data, buf[:8]...)
	{
		sub, err := o.ErrX.MarshalBinary()
		if err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
		data = append(data, buf[:8]...)
		data = append(data, sub...)
	}
	{
		sub, err := o.ErrY.MarshalBinary()
		if err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint64(buf[:8], uint64(len(sub)))
		data = append(data, buf[:8]...)
		data = append(data, sub...)
	}
	return data, err
}

// UnmarshalBinary implements encoding.BinaryUnmarshaler
func (o *Point2D) UnmarshalBinary(data []byte) (err error) {
	o.X = float64(math.Float64frombits(binary.LittleEndian.Uint64(data[:8])))
	data = data[8:]
	o.Y = float64(math.Float64frombits(binary.LittleEndian.Uint64(data[:8])))
	data = data[8:]
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		err = o.ErrX.UnmarshalBinary(data[:n])
		if err != nil {
			return err
		}
		data = data[n:]
	}
	{
		n := int(binary.LittleEndian.Uint64(data[:8]))
		data = data[8:]
		err = o.ErrY.UnmarshalBinary(data[:n])
		if err != nil {
			return err
		}
		data = data[n:]
	}
	return err
}
